#define _GNU_SOURCE
#include <sched.h>
#include <stdio.h>
#include <stdlib.h>
#include <time.h>
#include <unistd.h>
#include <math.h>
#include <omp.h>
#include <papi.h>

#define CACHE_L1_SIZE (896 * 1024)  // L1 cache size (896 KB)
#define CACHE_L2_SIZE (7 * 1024 * 1024)  // L2 cache size (7 MB)
#define ELEMENT_SIZE sizeof(double)  // Size of each matrix element in bytes
long long global_flop_counter = 0;

// Function to multiply blocks and accumulate the result in C (column-major order)
void multiply_block(double* A_block, double* B_sliver, double* C_block, int m_r, int n_r, int k_c) {
    // Perform multiplication C_ij += A_ik * B_kj, where A_ik is in L2 cache and B_kj in L1 cache.
    for (int j = 0; j < n_r; j++) {  // Iterating through columns of B and C
        for (int i = 0; i < m_r; i++) {  // Iterating through rows of A and C
            double sum = 0.0;
            for (int k = 0; k < k_c; k++) {  // Iterating through columns of A and rows of B
                sum += A_block[i + k * m_r] * B_sliver[k + j * k_c];   // Column-major access for A and B
                global_flop_counter += 2;
            }
            C_block[j * m_r + i] += sum;  // Column-major access for C
        }
    }
}

// Blocked matrix multiplication function using Goto and Van de Geijn algorithm (column-major order)
void gebp(int N, double* A, double* B, double* C, int m_c, int k_c, int n_r, int m_r) {
    // Allocate blocks of A, B (sliver), and C to fit into L1 and L2 cache
    double* A_block = (double*)malloc(m_c * k_c * sizeof(double));
    double* B_sliver = (double*)malloc(k_c * n_r * sizeof(double));
    double* C_block = (double*)malloc(m_r * n_r * sizeof(double));

    // Loop over the k dimension (columns of A, rows of B)
    for (int k_block = 0; k_block < N; k_block += k_c) {
        // Loop over the i dimension (rows of A, rows of C)
        for (int i_block = 0; i_block < N; i_block += m_c) {
            // Load a block of A (A_ik) into cache (column-major order)
            for (int k = 0; k < k_c && k_block + k < N; k++) {
                for (int i = 0; i < m_c && i_block + i < N; i++) {
                   A_block[i + k * m_c] = A[(i_block + i) + (k_block + k) * N]; // Column-major access
                }
            }

            // Loop over the j dimension (columns of B, columns of C)
            for (int j_block = 0; j_block < N; j_block += n_r) {
                // Load a sliver of B (B_kj) into cache (column-major order)
                for (int j = 0; j < n_r && j_block + j < N; j++) {
                    for (int k = 0; k < k_c && k_block + k < N; k++) {
                        B_sliver[j * k_c + k] = B[(k_block + k) * N + (j_block + j)];  // Column-major access
                    }
                }

                // Load the corresponding block of C (C_ij) into cache (column-major order)
                for (int j = 0; j < n_r && j_block + j < N; j++) {
                    for (int i = 0; i < m_r && i_block + i < N; i++) {
                        C_block[j * m_r + i] = C[(j_block + j) * N + (i_block + i)];  // Column-major access
                    }
                }

                // Perform the block multiplication: C_ij += A_ik * B_kj
                multiply_block(A_block, B_sliver, C_block, m_r, n_r, k_c);

                // Store the result of C_ij back into memory (column-major order)
                for (int j = 0; j < n_r && j_block + j < N; j++) {
                    for (int i = 0; i < m_r && i_block + i < N; i++) {
                        C[(j_block + j) * N + (i_block + i)] = C_block[j * m_r + i];  // Column-major access
                    }
                }
            }
        }
    }

    // Free the allocated memory for the blocks
    free(A_block);
    free(B_sliver);
    free(C_block);
}

void check_cpu_affinity() {
    cpu_set_t mask;
    CPU_ZERO(&mask);
    if (sched_getaffinity(0, sizeof(mask), &mask) == -1) {
        perror("sched_getaffinity");
        exit(1);
    }
    printf("Affinity mask set to core(s): ");
    for (int i = 0; i < CPU_SETSIZE; i++) {
        if (CPU_ISSET(i, &mask)) {
            printf("%d ", i);
        }
    }
    printf("\n");
}

int main() {
    // Set CPU affinity to run on a single core
    cpu_set_t set;
    CPU_ZERO(&set);
    CPU_SET(0, &set);  // Bind to core 0
    if (sched_setaffinity(0, sizeof(set), &set) == -1) {
        perror("sched_setaffinity");
        exit(1);
    }

    check_cpu_affinity();  // Ensure that the program runs only on a single core
    omp_set_num_threads(1);

    int N = 512 * 8;  // Adjust the matrix size to ensure the runtime is at least 1 second.

    // Dynamically allocate memory for matrices A, B, and C
    double* A = (double*)malloc(N * N * sizeof(double));
    double* B = (double*)malloc(N * N * sizeof(double));
    double* C = (double*)malloc(N * N * sizeof(double));

    // Initialize matrices with random data
    for (int i = 0; i < N * N; i++) {
        A[i] = rand() % 10;
        B[i] = rand() % 10;
        C[i] = 0.0;
    }

    // Calculate block sizes based on the L1 and L2 cache
    int l1_kb_size = CACHE_L1_SIZE / 1024;
    int l2_kb_size = CACHE_L2_SIZE / 1024;

    int elem_l1 = CACHE_L1_SIZE / ELEMENT_SIZE;
    int elem_l2 = CACHE_L2_SIZE / ELEMENT_SIZE;

    int half_elem_size_l1 = elem_l1 / 2;
    int half_elem_size_l2 = elem_l2 / 2;

    printf("L1 cache size (KB)= %d \nL2 cache size (KB) = %d\n", l1_kb_size, l2_kb_size);
    printf("# elements L1 = %d \n# elements L2 = %d\n", elem_l1, elem_l2);
    printf("#/2 elements L1 = %d \n#/2 elements L2 = %d\n", half_elem_size_l1, half_elem_size_l2);

    int k_c = 200;  // Fit A_ik in L2 cache
    int m_c = k_c;  // Use square blocks for A
    int n_r = 8;    // Fit B_kj and C_ij in L1 cache
    int m_r = 8;    // Small blocks for register-level optimization
    // taskset -c 0 ./gotovan
    // gcc -fopenmp -O0 -march=native -fno-tree-vectorize -mno-fma goto_van.c -o gotovan

    // Print block sizes and matrix size
    printf("Matrix Size (N): %d\n", N);
    printf("Block Sizes: m_c = %d, k_c = %d, n_r = %d, m_r = %d\n", m_c, k_c, n_r, m_r);

    // Measure the time taken by the blocked matrix multiplication
    struct timespec start, end;
    clock_gettime(CLOCK_MONOTONIC, &start);

    // Call the blocked matrix multiplication function using the GEBP pattern
    gebp(N, A, B, C, m_c, k_c, n_r, m_r);

    clock_gettime(CLOCK_MONOTONIC, &end);

    double time_taken = (end.tv_sec - start.tv_sec) + (end.tv_nsec - start.tv_nsec) / 1e9;
    printf("Time taken: %f seconds\n", time_taken);

    // Calculate FLOPS and convert to GFLOPS
    double flops = ((double)N * N *N * 2.00) / time_taken;
    double gflops = flops / 1e9;
    printf("GFLOPS: %lf\n", gflops);

    // Compute checksum to prevent compiler optimization
    double checksum = 0.0;
    for (int i = 0; i < N * N; i++) {
        checksum += C[i];
    }
    printf("Checksum: %f\n", checksum);

    // Free allocated memory
    free(A);
    free(B);
    free(C);


}
